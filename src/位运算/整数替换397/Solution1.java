package 位运算.整数替换397;

/**
 * 使用一个循环，内部对奇偶数进行处理：
 *
 * 偶数：其二进制低位为 0，直接无符号右移 1 位即可
 * 奇数：判断是 +1 还是 -1 => 应该能使下两轮循环能够直接进行无符号右移而无需再操作奇数
 * 为什么是下两轮呢？约定 7=>8=>4=>2=>1 是最优解而不是 7=>6=>3=>2=>1；
 * 前者进行一次奇数操作后，必定会连续进行两次无符号右移；
 * 而后者进行一次无符号右移后，又开始了一次奇数操作。
 *
 * 所以最优解应该保证奇数操作尽可能少，
 * 在操作奇数时，判断其 +1/-1 后是否能被 4 整除，
 * 接下来就能连续进行两次无符号右移了。
 *
 * 另外要注意 3 是特例，
 * 因为其最优解应该是 3=>2=>1，而不是 3=>4=>2=>1；
 * 只需对 3 执行 -1 操作即可。
 */
public class Solution1 {
    public int integerReplacement(int n) {
        int count = 0;
        /**
         * 单独考虑等于最大值的情况
         */
        if(n==Integer.MAX_VALUE){
            return 32;
        }
        while(n>1){
            if(n%2==0){
                n = n/2;
            }else if(n==3){
                n = n-1;
            }else {
                n = (n+1)%4==0?n+1:n-1;
            }
            count++;
        }
        return count;
    }
}
