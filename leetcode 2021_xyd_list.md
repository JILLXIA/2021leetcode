# leetcode 2021

[TOC]

## 1. 数组

### [1476. 子矩形查询](https://leetcode-cn.com/problems/subrectangle-queries/)

深拷贝（开辟新的内存空间） vs 浅拷贝(指向同一块内存空间)

java里面的clone()函数默认是浅拷贝，开辟一个副本对象，但是对象里面元素的引用仍然是原来的。

改变原来对象的值，副本对象不会被修改。

![image-20210406133138796](/Users/xiayudi/Library/Application Support/typora-user-images/image-20210406133138796.png)

如果要重写clone方法，必须要实现Cloneable的接口



## 2. 链表

## 3. 字符串

//TODO

1. KMP算法

## 4. 树

## 5. DFS

## 6. BFS

## 7. 二分查找

## 8. 双指针

## 9. 动态规划

求最优值

核心是穷举

1. 重叠子问题
2. 状态转移方程（最关键）
3. 最优子结构

![image-20210610171949950](/Users/xiayudi/Library/Application Support/typora-user-images/image-20210610171949950.png)

base case->穷举状态-》状态转移









## 10. 排序

## 11. 回溯
组合，切割，子集，排列，棋盘（N皇后，解数独）问题可以用到回溯
所有回溯法都可以抽象成树形结构（N叉树）
树的叉 横方向（for循环）
树的深度用递归处理
通常递归函数没有返回值，起名backtracking
1. 确定参数
2. 确定终止条件，搜集结果，通常在叶子节点搜集结果，子集问题是在每一个节点搜集结果
3. 单层搜索逻辑，for循环，便利集合每一个元素，处理节点
4. 递归操作
5. 回溯 撤销上一个添加的节点

## 12. 位运算

### Rabin-Karp算法[https://www.jianshu.com/p/24895aca0459]

1. 首先计算模式字符串的散列函数；
2. 然后利用相同的散列函数计算文本中所有可能的M个字符的子字符串的散列函数值并寻找匹配

但是这种方法比暴力查找还慢，因为计算散列值会涉及字符串中的每个字符。Rabin和Karp对上述方法进行了改进，发明了一种能够在**常数时间**内算出M个字符的子字符串散列值的方法。

一般的比较方法是逐位去比较，这样的时间复杂度就是O(mn)

Rabin Karp算法的核心是，将哈希函数使用滚动哈希来计算，这样计算哈希的复杂度是O(1)，整体的复杂度就变成了O(m)了。

寻找一个大素数（作为散列表的大小），通过**“除留余数法”**计算模式串的散列值。然后依次计算文本中的相同长度子串的散列值，进行比较。

我们知道，对于一个只有数字的字符串`a[0]a[1]a[2]...a[n]`要转换成十进制的数字，公式如下：

```
num = a[n]*10^0 + a[n-1]*10^1 + a[n-2]*10^2 + ... + a[1]*10^(n-1) + a[0]*10^n
```

在此基础上，我们往外延伸，如果对于一个只有小写英文字符的字符串来说，我们是不是可以当成26进制，然后计算出一个字符串所代表的数字：

```
num = a[n]*26^0 + a[n-1]*26^1 + a[n-2]*26^2 + ... + a[1]*26^(n-1) + a[0]*26^n
```

比如对于一个字符串”abcd”，我们要计算一个长度为2的子串的子串的哈希，先计算”ab”的：
`hash1 = code(a)*26^1 + code(b)*26^0`

再计算”bc”的：
`hash2 = code(b)*26^1 + code(c)*26^0`

看一下这里的规律，在计算hash2时，我们完全可以复用hash1的值，`hash2=(hash1-code(a)*26^1)*26+code(c)*26^0`





## 13. 贪心算法

## 待复习的收藏题目
421（字典树解法）
337 长度为2的数组的动态规划解法
518 待优化为1维数组

## TreeSet
TreeSet插入是无序的，但是可以后期自己排序
```
TreeSet<student> ts=new TreeSet<student>(new Comparator<student>() {

        @Override
        public int compare(student o1, student o2) {
            int num=o1.age-o2.age;
            int num2=num==0?o1.number-o2.number:num;
            return num2;
        }
    });
```
通过匿名内部类重写compare方法
遍历的时候取出来就是有序的了



# java 序列化

https://juejin.cn/post/6844903848167866375