# leetcode 2021

[TOC]

## 1. 数组

### [1476. 子矩形查询](https://leetcode-cn.com/problems/subrectangle-queries/)

深拷贝（开辟新的内存空间） vs 浅拷贝(指向同一块内存空间)

java里面的clone()函数默认是浅拷贝，开辟一个副本对象，但是对象里面元素的引用仍然是原来的。

改变原来对象的值，副本对象不会被修改。

![image-20210406133138796](/Users/xiayudi/Library/Application Support/typora-user-images/image-20210406133138796.png)

如果要重写clone方法，必须要实现Cloneable的接口



## 2. 链表

## 3. 字符串

//TODO

1. KMP算法

## 4. 树

## 5. DFS

## 6. BFS

## 7. 二分查找

## 8. 双指针

## 9. 动态规划

## 10. 排序

## 11. 回溯

## 12. 位运算

### Rabin-Karp算法[https://www.jianshu.com/p/24895aca0459]

1. 首先计算模式字符串的散列函数；
2. 然后利用相同的散列函数计算文本中所有可能的M个字符的子字符串的散列函数值并寻找匹配

但是这种方法比暴力查找还慢，因为计算散列值会涉及字符串中的每个字符。Rabin和Karp对上述方法进行了改进，发明了一种能够在**常数时间**内算出M个字符的子字符串散列值的方法。

一般的比较方法是逐位去比较，这样的时间复杂度就是O(mn)

Rabin Karp算法的核心是，将哈希函数使用滚动哈希来计算，这样计算哈希的复杂度是O(1)，整体的复杂度就变成了O(m)了。

寻找一个大素数（作为散列表的大小），通过**“除留余数法”**计算模式串的散列值。然后依次计算文本中的相同长度子串的散列值，进行比较。

我们知道，对于一个只有数字的字符串`a[0]a[1]a[2]...a[n]`要转换成十进制的数字，公式如下：

```
num = a[n]*10^0 + a[n-1]*10^1 + a[n-2]*10^2 + ... + a[1]*10^(n-1) + a[0]*10^n
```

在此基础上，我们往外延伸，如果对于一个只有小写英文字符的字符串来说，我们是不是可以当成26进制，然后计算出一个字符串所代表的数字：

```
num = a[n]*26^0 + a[n-1]*26^1 + a[n-2]*26^2 + ... + a[1]*26^(n-1) + a[0]*26^n
```

比如对于一个字符串”abcd”，我们要计算一个长度为2的子串的子串的哈希，先计算”ab”的：
`hash1 = code(a)*26^1 + code(b)*26^0`

再计算”bc”的：
`hash2 = code(b)*26^1 + code(c)*26^0`

看一下这里的规律，在计算hash2时，我们完全可以复用hash1的值，`hash2=(hash1-code(a)*26^1)*26+code(c)*26^0`





## 13. 贪心算法





